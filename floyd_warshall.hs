{-| 
Written by Gabriel Arellano (garellano88@gmail.com)

This file contains code which will solve the shortest path problem for
a provided matrix.

The first section has the main methods which will perform the
Floyd-Warshal algorithm, which solves the shortest path problem. I
found this algorithm easier to implement than Djikstra's algorithm in
Haskell. The second section of the code contains several helper
methods. The third section defines some graphs as variables for easy
testing. Please feel free to modify these values to test the
algorithm.

 -}

-- ##################################################################
{-|
The find_shortest_length method will accept two node numbers and a
matrix as its input and will return the smallest distance between the
two specified nodes using the Floyd-Warshall (FW) algorithm. To
accomplish this, the function simply chooses the correct element from
the distance matrix created by the FW algorithm. This function calls
another method to create this distance matrix.
-}
find_shortest_length :: Int -> Int -> [[Double]] -> Double
find_shortest_length node1 node2 matrix = 
  fetch_val (node2, node1) distance_matrix
  where distance_matrix = get_distance_matrix matrix node_list
        node_list = [1..n]
        n = length matrix

{-|
The get_distance_matrix' method recursively evaluates the distance
matrix for each node by taking the head of the node list generated by
the previous get_distance_method and processing the matrix with the FW
algorithm. Each recursive call uses the updated matrix generated by
the FW algorithm in the where clause.

Notice that this method also sets up each row and column with the
get_*_edges methods, which provide the algorithm with the row and
column location for each value, which simplifies the writability of
the algorithm at the expense of some readability. Also note that these
methods are called with specifically the nth row and nth column, where
n is the current node number.
-}
get_distance_matrix :: [[Double]] -> [Int] -> [[Double]]
get_distance_matrix matrix node_list
  | node_list == [] = matrix
  | otherwise       = get_distance_matrix next_matrix remaining_nodes
                      where next_matrix = floyd_warshall matrix row column
                            row = get_row_edges current_node (fetch_from_index current_node matrix) 1
                            column = get_column_edges current_node (strip_column current_node matrix) 1
                            current_node:remaining_nodes = node_list
                            

{-|
The floyd_warshall method further sets up the FW algorithm by taking
each row entry from the provided row of entries and passing the single
row entry to the floyd_warshall' method along with the entire column
of entries. Each iteration of the latter method will update the
matrix, which is provided to recursive calls of the floyd_warshall
method.
-}
floyd_warshall :: [[Double]] -> [(Double, (Int, Int))] -> [(Double, (Int, Int))] -> [[Double]]
floyd_warshall matrix row column 
  | row == [] = matrix
  | otherwise = floyd_warshall next_matrix next_row column 
  where next_matrix = floyd_warshall' matrix entry column
        entry:next_row = row

{-|
The floyd_warshall' method evaluates each row entry that it is given
by checking if the row entry's value is 0, infinity (or > 9*10^9), or
a basic number. In the case of a 0 or infinity, the value is
ignored. Why? Within the FW algorithm, the idea is that by comparing
the distance from node a to node b and the distance from node b to
node c, a value for the distance of a to c can be derived. When an
entry has a value of 0, that relates to the distance of a node to
itself, and infinity correlates to an unkown distance between two
nodes; obviously these two values are not helpful in calculating a to
b to b in the former case and a to b to ? in the latter case.

If the row entry's value is something besides 0 and infinity, then the
row entry is evaluated for the entire column provided via the
floyd_warshall'' method, which returns the next matrix to be
recursively evaluated by the floyd_warshall' method for the next entry
from the column. The method terminates when the column of entries is
empty (i.e. all entries have been processed).
-}
floyd_warshall' :: [[Double]] -> (Double, (Int,Int)) -> [(Double, (Int, Int))] -> [[Double]]
floyd_warshall' matrix entry column
  | entry_val == 0          = matrix
  | entry_val > (9*(10^99)) = matrix
  | column == []            = matrix
  | otherwise = floyd_warshall' next_matrix entry next_column
  where entry_val = fst entry   --- filter results by entry value
        next_matrix = floyd_warshall'' matrix entry col_entry
        col_entry:next_column = column

{-|
This method similarly evaluates the provided column entry, and
discards entries that are worth 0 or infinity. Then the core aspect of
the FW algorithm is evaluated - if the combination of two entries
(which is the equivalent to the sum of the distance from node i to a
and the distance from node a to j) is less than the current entry for
the distance from node i to j, then the combined distance from i-a-j
is set for the new distance from i to j. For some great visual
examples of the algorithm, please refer to the following resources:

Wikipedia:
http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm

Lecture notes from CIS Dept., Hosei Univ. in Japan:
http://cis.k.hosei.ac.jp/~rhuang/Miccl/Algorithm3/lect24-floyd-warshall.pdf
-}
floyd_warshall'' :: [[Double]] -> (Double, (Int,Int)) -> (Double, (Int,Int)) -> [[Double]]
floyd_warshall'' matrix row_entry col_entry
  | col_val == 0          = matrix
  | col_val > (9*(10^99)) = matrix
  | otherwise = if combined_dist < current_mtrx_dist then update_matrix else matrix 
  where update_matrix = replace_mtrx_value current_entry combined_dist matrix
        combined_dist = (fst row_entry) + (fst col_entry)
        current_mtrx_dist = fetch_val current_entry matrix
        current_entry = (fst (snd row_entry), snd (snd col_entry))
        col_val = fst col_entry

-- ##################################################################
-- This section contains helper methods for my implementation of the
-- Floyd-Warshal algorithm.

{-| 
The replace method simply replaces an element in an array.  
-}
replace :: Int -> a -> [a] -> [a]
replace 1 value lst = value:(tail lst)
replace index value lst = 
  fst (splitAt (index-1) lst) ++ [value] ++ snd (splitAt index lst)

{-|
I chose to implement this method in lieu of using !! because I wanted
to keep the matrix indices consistent; i.e. an adjacency matrix is
considered n by n in dimensions, and that numbering implies the first
entry is index one and the last index is n. The use of !!, on the
other hand, uses indices starting at 0 to (n-1).
-}
fetch_from_index :: Int -> [a] -> a
fetch_from_index 0 lst = error "Indices begin at 1, cannot fetch from index 0!"
fetch_from_index 1 lst = head lst
fetch_from_index index lst = last (fst (splitAt index lst))

{-|
The strip column method takes a matrix and removes the nth element
from each list, thus returning the nth column within the matrix.
-}
strip_column :: Int -> [[Double]] -> [Double]
strip_column n matrix 
  | matrix == [] = []
  | otherwise = (fetch_from_index n (head matrix)):strip_column n (tail matrix)

{-|
The fetch_val method was implemented since the final product of the
Floyd-Warshall algorithm used is a matrix containing the distance from
any node to any other node. Thus, to get the shortest length between
two nodes a single entry from a matrix needs to be returned.
-}
fetch_val :: (Int,Int) -> [[Double]] -> Double
fetch_val (x,y) matrix = fetch_from_index x (fetch_from_index y matrix)

{-|
I created replace_mtrx_value because I wanted a simple method to
update my matrix with a new value in a specified location.
-}
replace_mtrx_value :: (Int, Int) -> Double -> [[Double]] -> [[Double]]
replace_mtrx_value (x,y) value matrix =
  replace y (replace x value (fetch_from_index y matrix)) matrix


{-|
The get_row_edges method will take a specified row index that belongs
to a row within a matrix, the row itself from the matrix, and a
col_index COUNTER which will iterate through each entry within the row
and return a modified tuple version of the entry of the form (Value,
(X,Y)).
-}
get_row_edges :: Int -> [Double] -> Int -> [(Double, (Int,Int))]
get_row_edges row_index row col_index
  | row == [] = []
  | otherwise = (val, (col_index,row_index)):get_row_edges row_index next_row (col_index+1)
  where val:next_row = row

{-|
The get_column_edges method will take a specified column index that
belongs to a column within a matrix, the column itself from the
matrix, and a row_index COUNTER which will iterate through each entry
within the column and return a modified tuple version of the entry of
the form (Value, (X,Y)).
-}
get_column_edges :: Int -> [Double] -> Int -> [(Double, (Int,Int))]
get_column_edges col_index column row_index
  | column == [] = []
  | otherwise    = (val, (col_index,row_index)):get_column_edges col_index next_column (row_index+1)
  where val:next_column = column
  


-- ##################################################################
{-  This section contains some sample graphs for evaluation   -}

test_graph = [ [0,   5,   3,   1/0,  1/0, 1/0, 1/0, 1/0],
              [5,   0,   7,   10,   8,   1/0, 1/0, 1/0],
              [3,   7,   0,   1/0,  5,   1/0, 7,   1/0],
              [1/0, 10,  1/0, 0,    4,   2,   1/0, 1/0],
              [1/0, 8,   5,   4,    0,   4,   7,   5],
              [1/0, 1/0, 1/0, 2,    4,   0,   7,   8],
              [1/0, 1/0, 7,   1/0,  7,   7,   0,   2],
              [1/0, 1/0, 1/0, 1/0,  5,   8,   2,   0]]

graph2 = [[0,   1,   1/0, 4],
          [1,   0,   2,   7],
          [1/0, 2,   0,   3],
          [4,   7,   3,   0]]

graph3 = [[0,   4,   4,   5,   1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0],
          [4,   0,   1/0, 2,   1/0, 1/0, 8,   1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0],
          [4,   1/0, 0,   3,   5,   1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0],
          [5,   2,   3,   0,   7,   8,   9,   1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0],
          [1/0, 1/0, 5,   7,   0,   1,   1/0, 8,   9,   1/0, 1/0, 1/0, 1/0, 1/0], --row 5
          [1/0, 1/0, 1/0, 8,   1,   0,   3,   1/0, 2,   5,   1/0, 1/0, 1/0, 1/0],
          [1/0, 8,   1/0, 9,   1/0, 3,   0,   1/0, 1/0, 7,   4,   1/0, 1/0, 1/0],
          [1/0, 1/0, 1/0, 1/0, 8,   1/0, 1/0, 0,   1/0, 1/0, 1/0, 1,   1/0, 1/0],
          [1/0, 1/0, 1/0, 1/0, 9,   2,   1/0, 1/0, 0,   3,   1/0, 1/0, 1/0, 4],
          [1/0, 1/0, 1/0, 1/0, 1/0, 5,   7,   1/0, 3,   0,   2,   1/0, 6,   1/0], --row 10
          [1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 4,   1/0, 1/0, 2,   0,   1/0, 4,   1/0],
          [1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1,   1/0, 1/0, 1/0, 0,   10,  1/0],
          [1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 6,   4,   10,  0,   5],
          [1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 1/0, 4,   1/0, 1/0, 1/0, 5,   0]]
